<!-- _includes/3d-background.html -->
<canvas id="bg-canvas" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none;"></canvas>

<script>
(function () {
  if (!window.THREE || document.getElementById('bg-canvas').__initialized) return;
  document.getElementById('bg-canvas').__initialized = true;

  const canvas = document.getElementById('bg-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.z = 30;

  const group = new THREE.Group();
  scene.add(group);

  const materials = [
    new THREE.MeshStandardMaterial({ color: 0x3b82f6, wireframe: true, transparent: true, opacity: 0.18 }),
    new THREE.MeshStandardMaterial({ color: 0x6366f1, wireframe: true, transparent: true, opacity: 0.14 }),
    new THREE.MeshStandardMaterial({ color: 0x60a5fa, wireframe: true, transparent: true, opacity: 0.12 }),
  ];
  const geometries = [
    new THREE.IcosahedronGeometry(3, 1),
    new THREE.OctahedronGeometry(2.5, 0),
    new THREE.TorusGeometry(2, 0.6, 8, 20),
    new THREE.TetrahedronGeometry(2, 0),
    new THREE.DodecahedronGeometry(2, 0),
    new THREE.TorusKnotGeometry(1.5, 0.5, 50, 8),
  ];

  const shapes = [];
  for (let i = 0; i < 14; i++) {
    const mesh = new THREE.Mesh(geometries[i % geometries.length], materials[i % materials.length]);
    mesh.position.set((Math.random() - 0.5) * 44, (Math.random() - 0.5) * 32, (Math.random() - 0.5) * 20);
    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
    mesh.userData = {
      rx: (Math.random() - 0.5) * 0.007,
      ry: (Math.random() - 0.5) * 0.005,
      phase: Math.random() * Math.PI * 2,
      speed: 0.3 + Math.random() * 0.5,
      amp: 0.4 + Math.random() * 1.2,
    };
    group.add(mesh);
    shapes.push(mesh);
  }

  const pGeo = new THREE.BufferGeometry();
  const positions = new Float32Array(250 * 3);
  for (let i = 0; i < positions.length; i++) positions[i] = (Math.random() - 0.5) * 60;
  pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  scene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0x3b82f6, size: 0.07, transparent: true, opacity: 0.45 })));

  scene.add(new THREE.AmbientLight(0x3b82f6, 0.4));
  const dir = new THREE.DirectionalLight(0xffffff, 0.25);
  dir.position.set(5, 5, 5);
  scene.add(dir);

  let mx = 0, my = 0;
  document.addEventListener('mousemove', e => {
    mx = (e.clientX / window.innerWidth - 0.5) * 2;
    my = (e.clientY / window.innerHeight - 0.5) * 2;
  });

  (function animate(t) {
    requestAnimationFrame(animate);
    const time = t * 0.001;
    group.rotation.y += (mx * 0.04 - group.rotation.y) * 0.018;
    group.rotation.x += (-my * 0.025 - group.rotation.x) * 0.018;
    shapes.forEach(m => {
      m.rotation.x += m.userData.rx;
      m.rotation.y += m.userData.ry;
      m.position.y += Math.sin(time * m.userData.speed + m.userData.phase) * 0.008 * m.userData.amp;
    });
    renderer.render(scene, camera);
  })(0);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>